### 1、Persist Level Parallelism: Streamlining Integrity Tree Updates for Secure Persistent Memory

#### 1.1、作者提出了安全内存持久化恢复NVM的优化模型需要满足的不变量，指出了之前的工作因为不满足这些不变量而大大地低估了提供安全性的BMT的更新成本。为此，作者做了一些优化对于BMT严格串行执行与纪元执行持久化模型，在前一种模式中，每个更新都具有严格的顺序性，而后一种模式中同一epoch中的更新可以不按相对顺序执行。

#### 1.2、作者提出了两个不变量。

* 第一个是崩溃恢复元组不变量1，其是由 (C, γ,M, R)组成，其中C是密文，γ是计数器，M为MAC消息验证码，R为BMT的根节点，需要满足该四个条件持久化，才能满足崩溃恢复。
* 第二个是持久化顺序不变量2，如果元组之间是具有相对顺序的，(C1, γ1, M1, R1) → (C2, γ2, M2, R2)，那么该元组之内的元组项也应该按照该相对顺序来持久化。

#### 1.3、基于这两个不变量的可持久化内存模型，发现其开销的瓶颈依然在BMT的更新上。因此，作者提出了关于BMT更新的三个优化。

* 基于严格顺序持久化的SP模式
  * 可以采用流水线的方法，使得具有相对顺序的持久化更新BMT能并行地持久化不同层级。
* 基于纪元持久化的EP模式
  * 在相同的纪元内采用乱序持久化，尽管流水线持久化确实能极大地降低持久化开销，但是乱序持久化的效果会比流水线更好。因为其不需要有不同层级持久化的限制。
  * 在持久化过程中可以采用合并持久化，在不同持久化的最大公共祖先之上的节点，都是共同需要持久化的节点，所以将其合并，只持久化一次。由于如果考虑太多节点以及使用LCA等复杂算法的开销过大，文中只合并前后两个持久化过程，仅仅使用前缀匹配确定其合并节点。

#### 1.4、扩展与思考

* 是否可以将作者关于BMT树的由叶子到根节点的更新应用在其他需要类似更新的其他方面？
  * merkle tree的更新需要从叶子节点更新到根节点，只有具备该性质的树结构才能采用相似的优化思路
* 是否能对合并算法进行更大程度的优化以获取更好的性能？
  * 文中作者只采用了两个持久化操作的合并，这样的收益比较小。是否能采用更大程度的合并，也就是说，将同一纪元的更新要更新的节点都进行标记，当要更新的点中标记待更新超过两个时，说明后面该点还有节点进行更新，故本次持久化之后的更新全部不需要执行，只需要将标记减去即可。